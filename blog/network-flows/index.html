<!DOCTYPE html><html> <head><meta charset="UTF-8"><meta name="description" content="Astro description"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/vnd.microsoft.icon" href="/favicon.ico"><meta name="generator" content="Astro v4.7.0"><title>网络流最大流算法总结（Edmonds-Karp 算法+Dinic 算法）</title><link rel="alternate" type="application/rss+xml" title="博客文章 RSS 订阅" href="https://skywt.cn/rss.xml"><link rel="sitemap" href="/sitemap-index.xml"><script>
      function addMatomo() {
        var _paq = (window._paq = window._paq || []);
        _paq.push(["trackPageView"]);
        _paq.push(["enableLinkTracking"]);
        (function () {
          var u = "//analytics.skywt.cn/";
          _paq.push(["setTrackerUrl", u + "matomo.php"]);
          _paq.push(["setSiteId", "1"]);
          var d = document,
            g = d.createElement("script"),
            s = d.getElementsByTagName("script")[0];
          g.async = true;
          g.src = u + "matomo.js";
          s.parentNode.insertBefore(g, s);
        })();
      }

      document.addEventListener(
        "astro:page-load",
        () => {
          addMatomo();
        },
        { once: false },
      );
    </script><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="stylesheet" href="/_astro/about.C1P3jhYu.css">
<link rel="stylesheet" href="/_astro/friends.CyDDfFZO.css">
<style>img[data-astro-cid-4sn4zg3r]{border-radius:.5rem;--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);--tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}
</style><script type="module" src="/_astro/hoisted.Chao4eaI.js"></script></head> <body> <header class="mt-12 container container--wide" data-astro-cid-3ef6ksr2> <h5 class="mt-4 mx-4 text-secondary sm:hidden text-center" data-astro-cid-3ef6ksr2> <a href="/" class="link">SkyWT</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
网络流最大流算法总结（Edmonds-Karp 算法+Dinic 算法） </span> </h5> </header> <nav class="py-2 font-thin sticky top-0 backdrop-blur-md z-10 transition-all" id="navbar-wrapper" data-astro-cid-3ef6ksr2> <div class="container container--wide flex justify-center sm:justify-between flex-wrap" data-astro-cid-3ef6ksr2> <h5 class="m-2 hidden sm:block text-secondary" data-astro-cid-3ef6ksr2> <a href="/" class="link">SkyWT</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
网络流最大流算法总结（Edmonds-Karp 算法+Dinic 算法） </span> </h5> <div class="m-2 text-secondary" data-astro-cid-3ef6ksr2> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> <i class="ri-home-line" data-astro-cid-tfcnbjmv></i>
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv> <i class="ri-newspaper-line" data-astro-cid-tfcnbjmv></i> 博客 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/friends" data-astro-cid-tfcnbjmv> <i class="ri-contacts-line" data-astro-cid-tfcnbjmv></i> 友人 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv> <i class="ri-cup-line" data-astro-cid-tfcnbjmv></i> 关于 </a> </li> </ul>  </div> </div> </nav> <script>
  // 使用 ViewTransition 后，所有 DOM 操作的 js 都有一堆问题
  // 这里用了极不优雅的 var，有待改进
  var observer;
  function addNavObserver() {
    const headerEl = document.querySelector("#navbar-wrapper");
    const sentinalEl = document.querySelector("header");
    if (!sentinalEl || !headerEl) return;
    observer = new window.IntersectionObserver((e) => {
      if (!e[0].isIntersecting) {
        headerEl.classList.add("sticked");
      } else {
        headerEl.classList.remove("sticked");
      }
    });
    observer.observe(sentinalEl);
  }

  function removeNavObserver() {
    if (observer) observer.disconnect();
    observer = null;
  }

  document.addEventListener(
    "astro:page-load",
    () => {
      addNavObserver();
    },
    { once: false },
  );

  document.addEventListener(
    "astro:before-swap",
    () => {
      removeNavObserver();
    },
    { once: false },
  );
</script>   <main data-astro-cid-4sn4zg3r> <section class="container mt-8 sm:mt-32" data-astro-cid-4sn4zg3r>  <h1 class="leading-relaxed" data-astro-cid-4sn4zg3r>网络流最大流算法总结（Edmonds-Karp 算法+Dinic 算法）</h1> <p class="mt-4 text-secondary leading-relaxed" data-astro-cid-4sn4zg3r> <i class="ri-calendar-line" data-astro-cid-4sn4zg3r></i> <span data-astro-cid-4sn4zg3r>2018 年 3 月 25 日 11:59</span> <!-- {
          post.commentsNum > 0 && (
            <>
              <br />
              <i class="ri-discuss-line" />
              <span>共 {post.commentsNum} 条评论</span>
            </>
          )
        } --> </p> <hr class="my-8" data-astro-cid-4sn4zg3r> <article class="content" data-astro-cid-4sn4zg3r> <h2><a id="文章目录" class="heading-anchor"></a>文章目录</h2>
<ul>
<li><a href="#%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9A%84%E5%AE%9A%E4%B9%89">网络流的定义</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9A%84%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8">网络流的三大基本性质</a></li>
<li><a href="#%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98">最大流问题</a>
<ul>
<li><a href="#edmonds-karp-%E7%AE%97%E6%B3%95">Edmonds-Karp 算法</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E8%BE%B9">如何存储边</a></li>
</ul></li>
<li><a href="#dinic-%E7%AE%97%E6%B3%95">Dinic 算法</a>
<ul>
<li><a href="#edmonds-karp-%E6%85%A2%E5%9C%A8%E5%93%AA%E9%87%8C">Edmonds-Karp 慢在哪里</a></li>
<li><a href="#%E5%88%86%E5%B1%82%E5%9B%BE">分层图</a></li>
<li><a href="#dinic-%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81">Dinic 算法核心代码</a></li>
<li><a href="#%E5%BD%93%E5%89%8D%E5%BC%A7%E4%BC%98%E5%8C%96">当前弧优化</a></li>
<li><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E5%90%AB%E5%BD%93%E5%89%8D%E5%BC%A7%E4%BC%98%E5%8C%96">完整代码（含当前弧优化）</a></li>
</ul></li>
<li><a href="#%E6%A8%A1%E6%9D%BF%E9%A2%98">模板题</a></li>
</ul></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
<blockquote>
<p>网络流（network-flows）是一种类比水流的解决问题方法，与线性规划密切相关。网络流的理论和应用在不断发展，出现了具有增益的流、多终端流、多商品流以及网络流的分解与合成等新课题。网络流的应用已遍及通讯、运输、电力、工程规划、任务分派、设备更新以及计算机辅助设计等众多领域。</p>
</blockquote>
<p>（2018.08.29 更新此文，你没有阅读过的船新版本）</p>
<p>网络流是信息学竞赛中的常见题型了。</p>
<h2><a id="网络流的定义" class="heading-anchor"></a>网络流的定义</h2>
<p>“网络流（network-flows）是一种类比水流的解决问题方法。”<br>
假设现在有一张有限的有向图 G，这张图上有一个源点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>，一个汇点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span>，每条边都有一个最大流量（即容量），就像复杂的水管网络。现在我们定义几个概念：</p>
<ul>
<li><strong>源点（Sources）</strong>：一切流量流入的点。</li>
<li><strong>汇点（Sinks）</strong>：所有流量最终汇聚到的点。</li>
<li><strong>容量（Capacity）</strong>：一条边的最大流量。</li>
<li><strong>残量（Residual Capacity）</strong>：容量与流量之差。</li>
</ul>
<h2><a id="网络流的三大基本性质" class="heading-anchor"></a>网络流的三大基本性质</h2>
<p>网络流任何时刻总满足以下三条性质：<br>
<strong>1. 容量限制（Capacity Constraints）</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>c</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(u,v)≤c(u,v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>，即一条边的流不能超过它的容量。（不然水管就要被挤爆了……）<br>
<strong>2. 斜对称（Skew Symmetry）</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(u,v)=-f(v,u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mclose">)</span></span></span></span>，即由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 的净流必须是由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 的净流的相反。假设有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的流量从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span> 流到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>，那么就相当于有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord mathnormal">x</span></span></span></span> 的流量从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span> 流到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>。<br>
<strong>3. 流守恒（Flow Conservation）</strong>：对于除了源点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 和汇点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 以外的所有点，都满足：</p>
<pre><code class="language-math">\displaystyle \sum_{p\in G} f(p,u)= \sum_{q\in G} f(u,q)
</code></pre>
<p>也就是说任何一个点的入流等于其出流，源点和汇点除外。</p>
<h2><a id="最大流问题" class="heading-anchor"></a>最大流问题</h2>
<p>现在假设有无限的流量从源点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 流入，我们要求出最后流到汇点t的最大流量（注意任何时候上面三个条件都要满足）。<br>
对于最大流问题可以用 Edmonds-Karp 算法或 Dinic 算法解决。后者是前者的优化，但是前者更易于理解，所以我们先了解 Edmonds-Karp 算法。</p>
<h3><a id="edmonds-karp-算法" class="heading-anchor"></a>Edmonds-Karp 算法</h3>
<p>Edmonds-Karp 算法（简称EK）的主要步骤如下：</p>
<ol>
<li>找到一条源点到汇点的路径（其中每条边残量都要大于0）（这样的路径就是<strong>增广路（Augmenting Path）</strong>），并找出这条路径上每条边残量最小值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">min</span></span></span></span>；</li>
<li>将这条路径上每条边残量减去 min，将每条边的反向边加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">min</span></span></span></span>（因为我们这条增广路是“随便找”的，不能保证解最优；将反向边加上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">min</span></span></span></span> 相当于提供了“反悔”的机会），并将答案累计上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">min</span></span></span></span>；</li>
<li>重复以上过程，直到从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> 没有增广路为止。</li>
</ol>
<p>（由于<del>我太懒</del>EK算法似乎在任何情况下都没有优化了的 Dinic 好，这里就不给出代码了……）</p>
<h4><a id="如何存储边" class="heading-anchor"></a>如何存储边</h4>
<p>要快速又节省空间地求出一条边的反向边并不简单。这里我们可以用邻接表存储：在读取边的信息的同时，<code>add(x,y,z)</code>，<code>add(y,x,0)</code>，这样一条边与其相邻边的边号总是相邻。我们如果<strong>从0开始存储边号</strong>，那么i的相邻边就是i^1，就是它的反向边！（^表示异或）</p>
<h3><a id="dinic-算法" class="heading-anchor"></a>Dinic 算法</h3>
<p>Dinic 算法是对 Edmonds-Karp 的优化。</p>
<h4><a id="edmonds-karp-慢在哪里" class="heading-anchor"></a>Edmonds-Karp 慢在哪里</h4>
<p>因为 EK 算法中走到各个点没有一定的顺序，可以理解为“任意”的，所以会出现一定的问题。假设从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 有两条路径走到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>（假设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 是增广路上的一个点），假设这两条路径中最小的残量分别为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">min1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">min</span><span class="mord">1</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">min2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">min</span><span class="mord">2</span></span></span></span>，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">min2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">min</span><span class="mord">2</span></span></span></span> 更大，我们应该选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">min2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">min</span><span class="mord">2</span></span></span></span> 这条路径，但是根据 EK 的处理方法我们会选择 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">min1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">min</span><span class="mord">1</span></span></span></span>，这样会导致重复处理。所以 EK 算法就会慢。</p>
<p>如何解决这个问题呢？Dinic 算法引入了“分层图”这个东西。</p>
<h4><a id="分层图" class="heading-anchor"></a>分层图</h4>
<p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 开始通过 BFS 构造分层图，这样可以保证日后 DFS 使用的从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span> 到达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的路径都是“最短路”（也就是最优路径）。</p>
<h4><a id="dinic-算法核心代码" class="heading-anchor"></a>Dinic 算法核心代码</h4>
<pre><code class="language-cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">BFS</span><span class="hljs-params">()</span></span>{<span class="hljs-comment">//这个函数的作用是构造分层图同时返回有无增广路 </span>
    <span class="hljs-built_in">memset</span>(deep,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(deep));
    deep[s]=<span class="hljs-number">1</span>;<span class="hljs-comment">//源点的深度为1 </span>
    <span class="hljs-type">int</span> head=<span class="hljs-number">0</span>,tail=<span class="hljs-number">1</span>;que[tail]=s;
    <span class="hljs-keyword">while</span> (head!=tail){
        head++;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=lnk[que[head]];i!=<span class="hljs-number">-1</span>;i=nxt[i]) <span class="hljs-keyword">if</span> (w[i]&gt;<span class="hljs-number">0</span>&amp;&amp;deep[son[i]]==<span class="hljs-number">0</span>) deep[son[i]]=deep[que[head]]+<span class="hljs-number">1</span>,que[++tail]=son[i];
    }
    <span class="hljs-keyword">if</span> (deep[t]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//如果汇点深度为0说明没有被修正到，也就是说没有增广路 </span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> now)</span></span>{<span class="hljs-comment">//x为当前点，now为当前流量 </span>
    <span class="hljs-keyword">if</span> (x==t) <span class="hljs-keyword">return</span> now;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=cur[x];i!=<span class="hljs-number">-1</span>;i=cur[x]=nxt[i]) <span class="hljs-keyword">if</span> (deep[son[i]]==deep[x]+<span class="hljs-number">1</span>&amp;&amp;w[i]!=<span class="hljs-number">0</span>){
        <span class="hljs-type">int</span> nxtd=<span class="hljs-built_in">DFS</span>(son[i],<span class="hljs-built_in">min</span>(now,w[i]));
        <span class="hljs-keyword">if</span> (nxtd&gt;<span class="hljs-number">0</span>){
            w[i]-=nxtd;
            w[i^<span class="hljs-number">1</span>]+=nxtd;<span class="hljs-comment">//反向边加  </span>
            <span class="hljs-keyword">return</span> nxtd;<span class="hljs-comment">//向上传递 </span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Dinic</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">BFS</span>()){
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cur[i]=lnk[i];
        <span class="hljs-keyword">while</span> (<span class="hljs-type">int</span> now=<span class="hljs-built_in">DFS</span>(s,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>)) ans+=now;<span class="hljs-comment">//初始流量为正无穷 </span>
    }
}
</code></pre>
<h4><a id="当前弧优化" class="heading-anchor"></a>当前弧优化</h4>
<p>Dinic 算法仍然可以优化，这个优化称为“当前弧优化”。基于这样一个事实：任何一条增广路中一条边不会存在两次。所以我们可以加一个数组 <code>cur[x]</code> 表示当前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 这个点循环到的边。（具体参见完整代码）</p>
<h4><a id="完整代码含当前弧优化" class="heading-anchor"></a>完整代码（含当前弧优化）</h4>
<p>（洛谷模版题“最大网络流”（<a href="https://www.luogu.org/problemnew/show/P3376" title="P3376">P3376</a>）测评通过）</p>
<pre><code class="language-cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">10005</span>,maxe=<span class="hljs-number">200005</span>;
<span class="hljs-type">int</span> n,m,s,t,tot=<span class="hljs-number">-1</span>,ans=<span class="hljs-number">0</span>,nxt[maxe],son[maxe],w[maxe],deep[maxn],lnk[maxn],que[maxn],cur[maxn];
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>{
    <span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>,f=<span class="hljs-number">1</span>;<span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) {<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();}
    <span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) ret=ret*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>,ch=<span class="hljs-built_in">getchar</span>();
    <span class="hljs-keyword">return</span> ret*f;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span></span>{
    tot++;son[tot]=y;w[tot]=z;nxt[tot]=lnk[x];lnk[x]=tot;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-title">BFS</span><span class="hljs-params">()</span></span>{<span class="hljs-comment">//这个函数的作用是构造分层图同时返回有无增广路 </span>
    <span class="hljs-built_in">memset</span>(deep,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(deep));
    deep[s]=<span class="hljs-number">1</span>;<span class="hljs-comment">//源点的深度为1 </span>
    <span class="hljs-type">int</span> head=<span class="hljs-number">0</span>,tail=<span class="hljs-number">1</span>;que[tail]=s;
    <span class="hljs-keyword">while</span> (head!=tail){
        head++;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=lnk[que[head]];i!=<span class="hljs-number">-1</span>;i=nxt[i]) <span class="hljs-keyword">if</span> (w[i]&gt;<span class="hljs-number">0</span>&amp;&amp;deep[son[i]]==<span class="hljs-number">0</span>) deep[son[i]]=deep[que[head]]+<span class="hljs-number">1</span>,que[++tail]=son[i];
    }
    <span class="hljs-keyword">if</span> (deep[t]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//如果汇点深度为0说明没有被修正到，也就是说没有增广路 </span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> now)</span></span>{<span class="hljs-comment">//x为当前点，now为当前流量 </span>
    <span class="hljs-keyword">if</span> (x==t) <span class="hljs-keyword">return</span> now;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=cur[x];i!=<span class="hljs-number">-1</span>;i=cur[x]=nxt[i]) <span class="hljs-keyword">if</span> (deep[son[i]]==deep[x]+<span class="hljs-number">1</span>&amp;&amp;w[i]!=<span class="hljs-number">0</span>){
        <span class="hljs-type">int</span> nxtd=<span class="hljs-built_in">DFS</span>(son[i],<span class="hljs-built_in">min</span>(now,w[i]));
        <span class="hljs-keyword">if</span> (nxtd&gt;<span class="hljs-number">0</span>){
            w[i]-=nxtd;
            w[i^<span class="hljs-number">1</span>]+=nxtd;<span class="hljs-comment">//反向边加  </span>
            <span class="hljs-keyword">return</span> nxtd;<span class="hljs-comment">//向上传递 </span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">Dinic</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">BFS</span>()){
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cur[i]=lnk[i];
        <span class="hljs-keyword">while</span> (<span class="hljs-type">int</span> now=<span class="hljs-built_in">DFS</span>(s,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">30</span>)) ans+=now;<span class="hljs-comment">//初始流量为正无穷 </span>
    }
}
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-built_in">memset</span>(lnk,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(lnk));<span class="hljs-comment">//因为边号从0开始存储，所以-1表示没有边 </span>
    <span class="hljs-built_in">memset</span>(nxt,<span class="hljs-number">-1</span>,<span class="hljs-built_in">sizeof</span>(nxt));
    n=<span class="hljs-built_in">read</span>();m=<span class="hljs-built_in">read</span>();s=<span class="hljs-built_in">read</span>();t=<span class="hljs-built_in">read</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++){
        <span class="hljs-type">int</span> x=<span class="hljs-built_in">read</span>(),y=<span class="hljs-built_in">read</span>(),z=<span class="hljs-built_in">read</span>();
        <span class="hljs-built_in">add</span>(x,y,z);<span class="hljs-built_in">add</span>(y,x,<span class="hljs-number">0</span>);<span class="hljs-comment">//构造反向边并且其边号与正向边相邻 </span>
    }
    <span class="hljs-built_in">Dinic</span>();
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3><a id="模板题" class="heading-anchor"></a>模板题</h3>
<p><a href="https://www.luogu.org/problemnew/show/P3376" title="洛谷3376">洛谷3376</a><br>
<a href="http://poj.org/problem?id=1273" title="POJ1273">POJ1273</a></p>
<hr>
<h2><a id="参考" class="heading-anchor"></a>参考</h2>
<p><a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%B5%81" title="网络流_百度百科">网络流_百度百科</a><br>
<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%B5%81" title="网络流 - 维基百科，自由的百科全书">网络流 - 维基百科，自由的百科全书</a><br>
<a href="https://www.cnblogs.com/SYCstudio/p/7260613.html" title="Dinic算法（研究总结，网络流）">Dinic算法（研究总结，网络流）</a><br>
<a href="https://blog.csdn.net/dyt_b/article/details/79307596" title="网络流算法+例题整理 - CSDN博客">网络流算法+例题整理 - CSDN博客</a><br>
<a href="https://blog.csdn.net/qq_41357771/article/details/79416899" title="网络流【最大流&amp;&amp;最小割】——一篇简单易懂的博文">网络流【最大流&amp;&amp;最小割】——一篇简单易懂的博文</a><br>
<a href="http://www.matrix67.com/blog/archives/5190" title="网络流和棒球赛淘汰问题 | Matrix67: The Aha Moments">网络流和棒球赛淘汰问题 | Matrix67: The Aha Moments</a></p>
 </article> <hr class="my-8" data-astro-cid-4sn4zg3r> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();;(()=>{var A=Object.defineProperty;var g=(a,o,i)=>o in a?A(a,o,{enumerable:!0,configurable:!0,writable:!0,value:i}):a[o]=i;var d=(a,o,i)=>(g(a,typeof o!="symbol"?o+"":o,i),i);{let a={0:t=>m(t),1:t=>i(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(i(t)),5:t=>new Set(i(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},o=t=>{let[l,e]=t;return l in a?a[l](e):void 0},i=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="dNbdI" prefix="r0" component-url="/_astro/Comments.oDEb8ZXa.js" component-export="default" renderer-url="/_astro/client.DbokQZWz.js" props="{&quot;slug&quot;:[0,&quot;network-flows&quot;],&quot;data-astro-cid-4sn4zg3r&quot;:[0,true]}" ssr="" client="load" opts="{&quot;name&quot;:&quot;Comments&quot;,&quot;value&quot;:true}" await-children=""><h2><i class="ri-discuss-line"></i> 暂无评论</h2><hr class="my-8"/><h2><i class="ri-discuss-line"></i> 发表新的评论</h2><p class="mt-4 card card--in-content"><b>所有评论都将经过博主审核。</b>请勿填写无意义邮箱或发表无关评论、广告等，否则会被视为垃圾评论。</p><form class="mt-4 form"><input placeholder="你的名字" type="text" class="form__input" required="" value=""/><input placeholder="邮箱" type="email" class="form__input" required="" value=""/><input placeholder="网址" type="url" class="form__input" value=""/><textarea rows="8" class="sm:col-span-3 form__input" placeholder="说点什么吧……" required=""></textarea><button type="submit" class="sm:col-span-3 form__button">提交</button></form><p class="mt-4 text-secondary text-sm leading-normal">提交评论即表明你同意本网站使用 Cookie，并允许本站在后台记录你的邮箱、IP 地址等必要信息。<br/>（提交一次评论后，本提示将不再展示）</p><!--astro:end--></astro-island> </section> </main>  <footer class="mt-16 py-8 text-secondary"> <div class="container container--wide text-sm"> <div class="flex justify-between flex-wrap"> <div class="m-2"> <a href="/" class="link">SkyWT</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
网络流最大流算法总结（Edmonds-Karp 算法+Dinic 算法） </span> </div> <div class="m-2"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> 
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv>  博客 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv>  实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/friends" data-astro-cid-tfcnbjmv>  友人 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv>  关于 </a> </li> </ul>  </div> </div> <hr class="my-4"> <div class="flex justify-between flex-wrap"> <p class="m-2">
&#169; 2017-2024 <a href="/" class="link">SkyWT</a>
|
<a href="/sitemap-index.xml" class="link">站点地图</a>
|
<a href="/friends" class="link">友情链接</a>
|
<a href="https://foreverblog.cn/go.html" class="link">虫洞</a> <!-- |
        <a href="https://github.com/Skywt2003/Daydreamer" class="link"
          >Daydreamer</a
        > --> </p> <div class="m-2"> <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" class="inline-block mx-1" data-astro-cid-h3ykra2n> <img class="icon" src="/cc/cc.svg" data-astro-cid-h3ykra2n> <img class="icon" src="/cc/by.svg" data-astro-cid-h3ykra2n> <img class="icon" src="/cc/nc.svg" data-astro-cid-h3ykra2n>   </a>  <a href="https://notbyai.fyi" target="_blank" class="inline-block mx-1" data-astro-cid-hwbnc4sm> <img src="/not-by-ai-light.svg" alt="Not By AI Badge" class="badge inline-block dark:hidden" data-astro-cid-hwbnc4sm> <img src="/not-by-ai-dark.svg" alt="Not By AI Badge" class="badge hidden dark:inline-block" data-astro-cid-hwbnc4sm> </a>  <a href="https://www.foreverblog.cn/" target="_blank" class="inline-block mx-1"> <img src="https://img.foreverblog.cn/logo_en_default.png" alt="Forever Blog Badage" class="inline-block h-4 grayscale"> </a> </div> </div> <div class="flex justify-between flex-wrap"> <p class="m-2"> <a href="https://beian.miit.gov.cn/" target="_blank" class="link">
浙 ICP 备 2021019606 号 - 1</a>
|
<a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33080202000472" target="_blank" class="link before:content-[url('/mps.png')] before:align-middle">
浙公网安备 33080202000472 号</a> </p> <p class="m-2"> <!-- <span class="align-middle">由</span>
        <a
          href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"
          class="inline-block align-middle"
        >
          <img src="/upyun.png" class="h-6" />
        </a>
        <span class="align-middle">提供 CDN 加速、云存储服务</span> --> </p> </div> </div> </footer> </body></html>  