<!DOCTYPE html><html> <head><meta charset="UTF-8"><meta name="description" content="Astro description"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v4.1.1"><title>从零开始，配置一套现代前端工具链</title><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Noto+Serif+SC:wght@200;300;400;500;600;700;900&display=swap"><script>
      function addMatomo() {
        var _paq = (window._paq = window._paq || []);
        _paq.push(["trackPageView"]);
        _paq.push(["enableLinkTracking"]);
        (function () {
          var u = "//analytics.skywt.cn/";
          _paq.push(["setTrackerUrl", u + "matomo.php"]);
          _paq.push(["setSiteId", "1"]);
          var d = document,
            g = d.createElement("script"),
            s = d.getElementsByTagName("script")[0];
          g.async = true;
          g.src = u + "matomo.js";
          s.parentNode.insertBefore(g, s);
        })();
      }

      document.addEventListener(
        "astro:page-load",
        () => {
          addMatomo();
        },
        { once: false },
      );
    </script><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="stylesheet" href="/_astro/about.1W6dObU1.css" />
<style>img[data-astro-cid-4sn4zg3r]{border-radius:.25rem;--tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);--tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}
</style>
<link rel="stylesheet" href="/_astro/friends.S8xh7Zkr.css" /><script type="module" src="/_astro/hoisted.-OpaiJNX.js"></script></head> <body> <header class="mt-12 wide-container" data-astro-cid-3ef6ksr2> <h5 class="mt-4 mx-4 secondary-color sm:hidden text-center" data-astro-cid-3ef6ksr2> <a href="/" class="link">SkyWT</a> <span>
/
<a href="/blog" class="link"> 博客</a> </span><span>
/
从零开始，配置一套现代前端工具链 </span> </h5> </header> <nav class="py-2 font-thin sticky top-0 backdrop-blur-md z-10 transition-all" id="navbar-wrapper" data-astro-cid-3ef6ksr2> <div class="wide-container flex justify-center sm:justify-between flex-wrap" data-astro-cid-3ef6ksr2> <h5 class="m-2 hidden sm:block secondary-color" data-astro-cid-3ef6ksr2> <a href="/" class="link">SkyWT</a> <span>
/
<a href="/blog" class="link"> 博客</a> </span><span>
/
从零开始，配置一套现代前端工具链 </span> </h5> <div class="m-2 secondary-color" data-astro-cid-3ef6ksr2> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> <i class="ri-home-line" data-astro-cid-tfcnbjmv></i>
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv> <i class="ri-newspaper-line" data-astro-cid-tfcnbjmv></i> 博客 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/friends" data-astro-cid-tfcnbjmv> <i class="ri-contacts-line" data-astro-cid-tfcnbjmv></i> 友人 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv> <i class="ri-cup-line" data-astro-cid-tfcnbjmv></i> 关于 </a> </li> </ul>  </div> </div> </nav> <script>
  // 使用 ViewTransition 后，所有 DOM 操作的 js 都有一堆问题
  // 这里用了极不优雅的 var，有待改进
  var observer;
  function addNavObserver() {
    const headerEl = document.querySelector("#navbar-wrapper");
    const sentinalEl = document.querySelector("header");
    if (!sentinalEl || !headerEl) return;
    observer = new window.IntersectionObserver((e) => {
      if (!e[0].isIntersecting) {
        headerEl.classList.add("sticked");
      } else {
        headerEl.classList.remove("sticked");
      }
    });
    observer.observe(sentinalEl);
  }

  function removeNavObserver() {
    if (observer) observer.disconnect();
    observer = null;
  }

  document.addEventListener(
    "astro:page-load",
    () => {
      addNavObserver();
    },
    { once: false },
  );

  document.addEventListener(
    "astro:before-swap",
    () => {
      removeNavObserver();
    },
    { once: false },
  );
</script>   <main data-astro-cid-4sn4zg3r> <section class="container mt-8 sm:mt-32" data-astro-cid-4sn4zg3r>  <h1 class="primary-color leading-relaxed" data-astro-cid-4sn4zg3r>从零开始，配置一套现代前端工具链</h1> <p class="mt-4 secondary-color leading-relaxed" data-astro-cid-4sn4zg3r> <i class="ri-calendar-line" data-astro-cid-4sn4zg3r></i> <span data-astro-cid-4sn4zg3r>2024 年 03 月 16 日</span>   <br data-astro-cid-4sn4zg3r> <i class="ri-discuss-line" data-astro-cid-4sn4zg3r></i> <span data-astro-cid-4sn4zg3r>共 2 条评论</span>  </p> <hr class="my-8" data-astro-cid-4sn4zg3r> <p class="card p-2 my-8" data-astro-cid-4sn4zg3r>
⚙️ 全新博客前端仍在测试中。如果文章显示不正常，可以尝试访问<a href="https://blog.skywt.cn/posts/configure-a-modern-frontend-toolchain-from-scratch" class="link underline" data-astro-cid-4sn4zg3r>原博客的这篇文章</a>。
</p> <article class="content" data-astro-cid-4sn4zg3r> <p>现代前端应用框架（如 Next.js、Nuxt.js 等）都直接集成了完整的工具链，按照官方文档做，一行命令就可以配置完毕。这整套工具在我们调试和构建项目时，在背后做了大量工作。虽然这有助于快速上手，但是非常不利于我们了解其中的原理。</p><p>然而，各种工具纷繁复杂，文档浩如烟海。由于工具之多，即使文档再友好、工具本身再易用，也很难快速入门。</p><p><strong>本文将带你踏上一段旅程，从一个空文件夹开始，一步一步添加工具，最终配置一套完整的前端工具链。</strong>在其中，我们可以对各个工具的概念、用途和原理有一个比较系统的认识。每个部分都列出了相关文档的链接，方便查阅。</p><!--more--><p>我们使用 <strong>React.js</strong> 前端框架，使用 <strong>Tailwind</strong> 编写 CSS，使用 <strong>TypeScript</strong> 编写脚本，并使用 <strong>ESLint</strong> 进行代码检查。最终，希望达到和使用 create-react-app 工具创建的项目类似的开发体验。</p><h2>TL；DR</h2><p><strong>配置完毕后，整套工具链的示意图如下：</strong></p><p><img src="https://blog.skywt.cn/usr/uploads/2024/03/543791890.png" alt="配置完毕后的工具链示意图" title="配置完毕后的工具链示意图"></p><h2>从创建一个 npm 项目开始</h2><p>创建一个空目录（一般目录名就是项目名），进入其中执行 <code>npm init</code>，这个命令会交互式地让你填写该项目的元信息。</p><p>我们将这个项目命名为 <strong>study-chain</strong>（意为 study frontend toolchain）：</p><pre><code class="lang-bash">mkdir study-chain
cd study-chain
npm init</code></pre><p>确认信息之后，目录下会生成 <code>package.json</code> 文件，记录了项目的元信息：</p><pre><code class="lang-json">// package.json
{
  &quot;name&quot;: &quot;study-chain&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;SkyWT&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}</code></pre><p>接下来，我们以 <strong>moment</strong> 模块为例，这是一个用于转换日期格式的模块（这个模块其实已经废弃，不推荐新项目使用。我们只是将其作为示例，参见<a href="https://momentjs.com/docs/">文档</a>）。</p><p>在项目根目录下，使用 <code>npm i</code> 安装模块：</p><pre><code class="lang-bash">npm i moment</code></pre><p>我们只使用这个模块的一个功能为例：将模块引入为 <code>moment</code> 之后，<code>moment().format()</code> 返回当前日期时间字符串。</p><h2>Webpack</h2><p>让我们先忘掉 React.js，从编写纯 HTML 和 JavaScript 开始。<strong>如何在这个项目里使用之前安装的 moment 模块呢？</strong></p><p>考虑编写一个简单的 HTML 文件 <code>index.html</code>：</p><pre><code class="lang-html">&lt;html&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>这个 HTML 引用了 <code>index.js</code>。这个 js 文件引入了 moment 模块，将 div 内的内容设置为当前时间：</p><pre><code class="lang-js">// index.js
const moment = require(&quot;moment&quot;);

const app = document.getElementById(&quot;app&quot;);
app.innerText = moment().format();</code></pre><p><strong>当然，如果此时在浏览器中打开 HTML，这段 js 是无法运行的。</strong>因为 require 是 Node.js 的语法，浏览器并不支持。</p><p><strong>但是我们知道这个模块就在本地</strong>，它的源文件就在 <code>node_modules/moment</code> 路径下。我们需要一个工具<strong>获取这个模块，整合进这段 js 里</strong>。这种工具就叫做 <strong>bundler</strong>。有了 bundler，即使在用于前端的 js 中，我们也能引入模块了。</p><p><strong>Webpack</strong> 就是其中之一。</p><p><strong>类似的工具有：</strong>Rollup、Parcel。</p><h3>安装与使用</h3><p>首先安装 webpack 和 webpack-cli。后者是配套的命令行工具。这两个工具都只是在开发阶段使用，所以使用 <code>--save-dev</code> 安装为开发环境依赖：</p><pre><code class="lang-bash">npm i webpack webpack-cli --save-dev</code></pre><p>安装后，可以直接使用 <code>npx webpack</code> 命令：</p><pre><code class="lang-bash">npx webpack ./index.js --mode=development</code></pre><p>这个命令处理 <code>index.js</code> 文件，解析其中引用的模块，将对应的 js 代码注入该文件。参数 <code>--mode=development</code> 指示生成开发环境下易于调试的文件版本。如果在生产环境，应使用 <code>--mode=production</code>。</p><p>运行之后，会生成 <code>dist/main.js</code>（这是默认的输出文件，可配置），这就相当于<strong>浏览器版</strong>的源文件。于是，修改 HTML 中引用的 script 路径：</p><pre><code class="lang-html">&lt;html&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>用浏览器打开，可以发现成功地调用了该模块，div 中显示了当前的日期时间。</p><p>使用 <code>--watch</code> 参数可以使 webpack 保持运行，持续监听源文件的修改：</p><pre><code class="lang-bash">npx webpack ./index.js --mode=development --watch</code></pre><p>运行时，每当编辑 <code>index.js</code> 并保存，都会自动重新生成 <code>dist/main.js</code> 文件。可以在终端看到对应的输出。</p><p>除了 <code>require</code> 语法，webpack 也支持更常用的 <code>import</code> 语法。刚才的引入模块语句可以改成：</p><pre><code class="lang-js">// index.js
import moment from &quot;moment&quot;;
// ...</code></pre><h3>配置文件 webpack.config.js</h3><p>使用 webpack 的配置文件，可以替代运行命令时传递的参数，让命令行的使用更简洁和灵活。（<a href="https://webpack.js.org/configuration/">相关文档</a>）</p><p>在项目根目录创建名为 <code>webpack.config.js</code> 的文件，内容如下：</p><pre><code class="lang-js">// webpack.config.js
const path = require(&quot;path&quot;);
module.exports = {
  mode: 'development',
  entry: './index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, &quot;dist&quot;)
  }
};</code></pre><p>创建了配置文件之后，使用命令行时，只需要使用如下命令：</p><pre><code class="lang-bash">npx webpack
npx webpack --watch</code></pre><h3>设置 npm scripts</h3><p>为了方便起见，可以将以上 webpack 命令设置为 <strong>npm scripts</strong>。</p><p>编辑 <code>package.json</code> 文件，添加 scripts：</p><pre><code class="lang-json">// package.json
{
  // ...
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack&quot;,
    &quot;watch&quot;: &quot;webpack --watch&quot;
  },
  // ...
}</code></pre><p>保存之后，只需使用如下命令，就等同于运行设置的 webpack 命令：</p><pre><code class="lang-bash">npm run build
npm run watch</code></pre><p>为了表述方便，下文将运行 <code>npm run build</code> 命令的这一操作简称为 build。</p><h3>生成 HTML</h3><p>现在，构建完成后，访问 <code>index.html</code> 就能看到我们的网站。然而可以发现，这个 HTML 中 <code>main.js</code> 需要我们手动引用。能否让 webpack 帮我们完成这件事情呢？</p><p>这就需要让 webpack 为我们在 <code>dist</code> 目录中<strong>生成 HTML 文件</strong>。这可以通过 <strong>html-webpack-plugin</strong> 这个插件实现。没错，<strong>webpack 不仅是一个打包工具，其还拥有着丰富的插件生态</strong>。</p><p>运行以下命令安装 html-webpack-plugin（<a href="https://webpack.js.org/plugins/html-webpack-plugin/">文档</a>）：</p><pre><code class="lang-bash">npm i html-webpack-plugin --save-dev</code></pre><p>将 <code>index.html</code> 重命名为 <code>template.html</code>，内容如下：</p><pre><code class="lang-html">&lt;html&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>接下来修改 <code>webpack.config.js</code>，添加 html-webpack-plugin 插件的配置：</p><pre><code class="lang-js">// webpack.config.js
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
// ...
module.exports = {
  // ...
  plugins: [
    new HtmlWebpackPlugin({
      template: &quot;template.html&quot;
    })
  ]
};</code></pre><p>再次使用 build 构建，会发现 <code>dist</code> 目录下生成了 <code>index.html</code>，这个 HTML 引用了生成的 <code>main.js</code> 脚本。打开就能看见其实现了我们要的应用逻辑。</p><h3>使代码可以 import CSS 文件</h3><p>现在，有了 webpack 的加持，我们的 js 代码已经可以导入 module 了。但是如果需要引入其他静态资源，比如 CSS 文件，还是无法直接完成。为了使代码能直接 import 其他类型的文件，<strong>webpack 中可以安装配置一种称为 loader 的模块</strong>。</p><p>💡 <strong>Webpack 中的 loader 与 plugin：</strong>二者都是可以集成到 webpack 的模块，但是两个不同的概念。loader 一般用于处理特定类型的文件，而 plugin 可以提供更加广泛的功能。</p><p>比如，为了引入 CSS 文件，可以安装 <strong>style-loader</strong> 和 <strong>css-loader</strong> 两个模块（<a href="https://webpack.js.org/guides/asset-management/#loading-css">相关文档</a>）：</p><pre><code class="lang-bash">npm i style-loader css-loader --save-dev</code></pre><p>接下来，修改 webpack 配置文件，添加一条规则：对于文件名以 <code>.css</code> 结尾的文件，使用这两个模块：</p><pre><code class="lang-js">// webpack.config.js
// ...
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader'],
      },
    ],
  },
 };</code></pre><p>Webpack 会按照配置的顺序调用 loader。在该配置文件下，先调用 style-loader，再调用 css-loader。这两个 loader 分别的作用是：</p><ul><li><strong>style-loader</strong>：将一个 CSS 文件注入 DOM，放在 <code>&lt;style&gt;</code> 元素中。（<a href="https://webpack.js.org/loaders/style-loader/">文档</a>）</li><li><strong>css-loader</strong>：解析 CSS 中的 <code>@import</code> 和 <code>url()</code> 等语句，将对应引用的文件配置好。（<a href="https://webpack.js.org/loaders/css-loader">文档</a>）</li></ul><p>现在，可以使用 import 语句导入 CSS 文件了。首先还是在根目录下编写 <code>style.css</code> 文件：</p><pre><code class="lang-css">// style.css
.bg-gray {
  background-color: #aaa;
}</code></pre><p>保存后，修改 <code>index.js</code> 文件：</p><pre><code class="lang-js">// index.js
import moment from &quot;moment&quot;;
import &quot;./style.css&quot;;

const app = document.getElementById(&quot;app&quot;);
app.innerText = moment().format();

app.classList.add(&quot;bg-gray&quot;);</code></pre><p>重新 build 后，打开 HTML 即可发现样式的变化。</p><h2>PostCSS</h2><p>顾名思义。<strong>PostCSS</strong> 能够对 CSS 文件进行「后处理」（post-processing）。</p><p>和之前提到的 style-loader 和 css-loader 一样，PostCSS 也可以作为 loader 集成到 webpack。</p><h3>集成到 webpack</h3><p>首先还是安装 <strong>postcss-loader</strong>，同时安装 PostCSS 的一个插件 <strong>autoprefixer</strong>：</p><pre><code class="lang-bash">npm i postcss-loader autoprefixer --save-dev</code></pre><p>在 <code>webpack.config.js</code> 中添加配置：</p><pre><code class="lang-js">// webpack.config.js
// ...
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: [
          &quot;style-loader&quot;,
          {
            loader: &quot;css-loader&quot;,
            options: {
              importLoaders: 1,
            },
          },
          &quot;postcss-loader&quot;,
        ],
      },
    ],
  },
  // ...
}</code></pre><p>⚠️ <strong>注意：</strong>此处调用 css-loader 处添加了 options，将 <strong>importLoaders</strong> 设置为 1。这是考虑到 PostCSS 可能引入新的 <code>@import</code> 等语句，css-loader 要在其运行之后重新进行解析（<a href="https://webpack.js.org/loaders/css-loader/#importloaders">相关文档</a>）。如果确定 PostCSS 不会添加新的 <code>@import</code> 等语句，则此参数可不加。（可参考 <a href="https://github.com/webpack-contrib/css-loader/issues/228#issuecomment-312885975">GitHub 上的相关讨论</a>）</p><h3>配置文件 postcss.config.js</h3><p>接下来创建 PostCSS 的配置文件，项目根目录下的 <code>postcss.config.js</code> 文件（<a href="https://github.com/postcss/postcss?tab=readme-ov-file#webpack">文档</a>）：</p><pre><code class="lang-js">// postcss.config.js
/** @type {import('postcss-load-config').Config} */
module.exports = {
  plugins: [require(&quot;autoprefixer&quot;)],
};</code></pre><p>在以上的配置文件中，我们加载了 PostCSS 的 <strong>autoprefixer</strong> 插件（<a href="https://github.com/postcss/autoprefixer">文档</a>）。由于浏览器支持的差异，部分浏览器中使用某些样式需要加上特定的前缀，比如 <code>webkit</code> 或者 <code>moz</code>，这叫做 <strong>vendor prefix</strong>。这个插件会自动添加这种前缀，确保样式的兼容性。这里使用此插件只是为了演示 PostCSS 插件的使用，因为接下来我们将配置使用 Tailwind 插件。</p><p>PostCSS 是 webpack 的插件，autoprefixer 又是 PostCSS 的插件，也就是 webpack 的插件的插件。接下来我们还可以安装 Tailwind 的插件，即 webpack 的插件的插件的插件。<strong>前端工具链就是如此。</strong></p><h2>Tailwind CSS</h2><p>使用过 Tailwind 之后，在开发任何前端项目时，我的心理状态：</p><blockquote>没有它我不能活！😭😭😭</blockquote><p>是的，之后在开发任何前端项目的时候，我<strong>没有一次</strong>离开过 Tailwind。即使是写纯 HTML 也要从 CDN 引入静态文件。因为它彻底改变了我们编写样式的方式。</p><p>作为现代前端项目，Tailwind 当然是必备的工具。</p><h3>集成到 PostCSS</h3><p>首先还是安装 Tailwind：</p><pre><code class="lang-bash">npm install tailwindcss --save-dev</code></pre><p>接下来，在 PostCSS 中添加 Tailwind 插件（<a href="https://tailwindcss.com/docs/installation/using-postcss">官方指南</a>）：</p><pre><code class="lang-js">// postcss.config.js
/** @type {import('postcss-load-config').Config} */
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  }
};</code></pre><h3>配置文件 tailwind.config.js</h3><p>下一步，使用以下命令创建 Tailwind 的配置文件：</p><pre><code class="lang-bash">npx tailwindcss init</code></pre><p>Tailwind 会生成自己的配置文件 <code>tailwind.config.js</code>（<a href="https://tailwindcss.com/docs/configuration">文档</a>）：</p><pre><code class="lang-js">// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [&quot;./**/*.{html,js}&quot;],
  theme: {
    extend: {},
  },
  plugins: [],
}</code></pre><p>配置文件中的 <strong>content</strong> 的值，是一个字符串数组，其中存放着需要处理的文件路径。Tailwind 会尝试检测所有匹配的文件中出现的 class 值，并添加对应的 CSS 定义。</p><p>为了匹配我们根目录下的模板 HTML 和 js 文件，删除路径中 <code>src</code> 部分。（或者也可以将所有源文件放到 <code>src</code> 子目录里——大多数项目都是这样做的。下一步在整理文件环节，我们也会这样做）。</p><p>接下来，在我们引用的主样式表（即 <code>style.css</code>）的开头，<strong>加上 <code>@tailwind</code> 指令</strong>：</p><pre><code class="lang-css">// style.css
@tailwind base;
@tailwind components;
@tailwind utilities;

.bg-gray {
    background-color: #aaaaaa;
}</code></pre><p>大功告成。接下来可以尝试修改 HTML 模板并重新 build，就可以发现能使用 Tailwind 了！</p><pre><code class="lang-html">&lt;html&gt;
  &lt;body&gt;
    &lt;div class=&quot;text-4xl&quot; id=&quot;app&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre><p>（当然，集成到 PostCSS 并不是使用 Tailwind 的唯一方式。官方的<a href="https://tailwindcss.com/docs/installation">Get started</a> 中提供了大量框架、工具的集成指南）</p><h3>安装 Tailwind 插件</h3><p>没错，Tailwind 也有插件生态，比如 <strong>tailwindcss-animated</strong>（<a href="https://www.tailwindcss-animated.com">文档</a>）和 <strong>typography</strong>（<a href="https://github.com/tailwindlabs/tailwindcss-typography">文档</a>），这两个插件我都比较常用。</p><p>Tailwind 插件配置起来并不难，这里不再展开了，可以查阅相关文档。</p><h2>中场休息：整理目录结构</h2><p>至此，CSS 相关的工具配置完了。在进行下一步之前，是时候整理一下我们项目的目录结构了。</p><p>如前文所述，为了让项目目录更简洁，<strong>我们将所有源文件移动到新建的 <code>src</code> 文件夹内。</strong>移动之后，项目目录结构如下：</p><pre><code>node_modules/
  ...
dist/
  ...
src/
  template.html
  index.js
  style.css
package-lock.json
package.json
postcss.config.js
tailwind.config.js
webpack.config.js</code></pre><p>为了使所有工具只处理 <code>src</code> 目录下的文件，需要修改部分配置文件。</p><p>修改 <code>tailwind.config.js</code>：</p><pre><code class="lang-js">// tailwind.config.js
module.exports = {
  content: [&quot;./src/**/*.{html,js}&quot;],
  // ...
};</code></pre><p>修改 <code>webpack.config.js</code>：</p><pre><code class="lang-js">// webpack.config.js
module.exports = {
  // ...
  entry: &quot;./src/index.js&quot;,
  // ...
};</code></pre><p>这下，我们的项目目录就干净了很多。是时候进行下一步了！</p><h2>Babel</h2><p>JavaScript 是浏览器原生支持的唯一语言，但：1）不同浏览器对该语言的新特性支持有所不同；2）许多人不喜欢 JavaScript 弱类型的特性，TypeScript 应运而生。但浏览器本身不支持 TypeScript。</p><p>所以，需要这样一种工具：1）将 JavaScript 的新特性相关代码转换为使用旧特性的实现；2）将 TypeScript 翻译为 JavaScript。这个过程和 C++ 这类语言「编译」的过程有些相似，只是目标是 JavaScript 而非二进制。</p><p>这种工具就叫做 <strong>transpiler</strong>（可以翻译成「转译器」）。它的作用是将一段代码「翻译」成另一段代码，但目标代码仍然是高级语言（一般是 JavaScript）。这个「翻译」和传统编程语言中的「Compile」概念不同，称为「<strong>Transpile</strong>」。</p><p><strong>Babel</strong> 就是其中之一。</p><p>（吐槽：既然都要 transpile 才能运行代码，不如直接 compile 成更低级的字节码，执行效率还会更高。<strong>Web Assembly</strong> 就这样诞生了。不过这里不介绍了）</p><h3>集成到 webpack</h3><p>Babel 可以和 PostCSS 一样<strong>作为 loader 集成在 webpack 里</strong>。安装 Babel：</p><pre><code class="lang-bash">npm i babel-loader @babel/core --save-dev</code></pre><p>安装后，修改 webpack 配置文件，对 .js 文件使用 <strong>babel-loader</strong>（排除 <code>node_modules</code> 目录中的文件）：</p><pre><code class="lang-js">// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: &quot;babel-loader&quot;,
        },
      },
    ],
  },
};</code></pre><p>（同样，集成到 webpack 也非安装 Babel 的唯一方式。<a href="https://babeljs.io/setup#installation">官方指南</a>提供了很多种配置方式）</p><p>目前，重新 build 时，虽然会调用 babel-loader，但是 Babel 还什么事情都没做。这是因为我们没有为其指定任何规则。一般可以通过 <strong>preset</strong> 指定规则。</p><h3>presets</h3><p>Babel 中的 <strong>preset</strong> 这一概念，官方的定义是「可分享的一组插件和配置的集合」（<a href="https://babeljs.io/docs/presets">文档</a>）。</p><p>官方提供了四种 preset：</p><ul><li><strong>env</strong>：用于将较新的 ECMAScript 特性转译为兼容较旧环境的实现。</li><li><strong>react</strong>：用于转译 React.js 的 JSX 语法。</li><li><strong>typescript</strong>：用于转译 TypeScript。</li><li><strong>flow</strong>：用于 <a href="https://flow.org/">flow</a> 工具，这是一个静态类型检查器。</li></ul><h3>配置文件 babel.config.json</h3><p>在项目根目录下创建配置文件 <code>babel.config.json</code>，其中可以添加 preset 指定规则。我们先添加一个 preser-env：</p><pre><code class="lang-json">// babel.config.json
{
  &quot;presets&quot;: [&quot;@babel/preset-env&quot;]
}</code></pre><p>别忘了安装这个 preset：</p><pre><code class="lang-bash">npm i @babel/preset-env --save-dev</code></pre><p>安装和配置完毕后，重新 build，就会使用 preset-env 指定的 transpile 规则。这套规则有什么用呢？</p><h3>preset-env</h3><p>ECMAScript 标准每一两年都推出新的版本，引入新的特性。而不同浏览器对其的实现难免会有所滞后。为了：1）能及时使用 ECMAScript 的新特性；2）确保我们的代码在所有浏览器环境中的表现一致，<strong>Babel 提供的 preset-env 可以将使用新特性的代码 transpile 为使用旧特性的实现。</strong>（<a href="https://babeljs.io/docs/babel-preset-env">文档</a>）（在 Babel 出现之前，许多应用引入一个静态的 js 脚本完成这一功能，这种脚本叫做「polyfill」）</p><p>比如，ES6 引入了箭头函数和 const 关键字：</p><pre><code class="lang-js">const a = [1,2,3];
a.forEach((x) =&gt; console.log(x));</code></pre><p>如果要兼容不支持 ES6 的环境（虽然所有现代浏览器都已经支持了 ES6），Babel 就要将箭头函数转换成普通函数，const 换成 var：</p><pre><code class="lang-js">var a = [1, 2, 3];
a.forEach(function (x) {
  return console.log(x);
});</code></pre><p>可以在官网的 <a href="https://babeljs.io/repl">Try it out</a> 中尝试。</p><h2>TypeScript</h2><p>TypeScript 也是开发现代 Web 应用的必备。如果 standalone 地安装，可以使用 <code>tsc</code> 命令将一个 .ts 文件 transpile 成一个 .js 文件。然而，为了使这一过程在 build 时自动完成，还是要将其集成到 Babel。</p><h3>集成到 Babel</h3><p>如前所述，Babel 已经提供了 TypeScript 的 preset（<a href="https://babeljs.io/docs/babel-preset-typescript">文档</a>），其中包含了转译 TypeScript 的插件。只需直接安装：</p><pre><code class="lang-bash">npm i @babel/preset-typescript --save-dev</code></pre><p>在 <code>webpack.config.js</code> 中，要修改两个地方：1）将 entry 改为 <code>index.ts</code>；2）将 babel-loader 的 test 规则改为匹配 .ts 结尾的文件：</p><pre><code class="lang-js">// webpack.config.js
module.exports = {
  // ...
  entry: &quot;./src/index.ts&quot;,
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        use: {
          loader: &quot;babel-loader&quot;,
        },
      },
    ],
  },
};
</code></pre><p>在 <code>babel.config.json</code> 里，加入 <strong>preset-typescript</strong>：</p><pre><code class="lang-json">// babel.config.json
{
  &quot;presets&quot;: [
    &quot;@babel/preset-env&quot;,
    &quot;@babel/preset-typescript&quot;
  ]
}</code></pre><p>现在，可以将 <code>src</code> 中的 <code>index.js</code> 改写为 <code>index.ts</code> 了。由于这段代码很短，只需要改一个地方，即判断 <code>app</code> 是否为 <code>null</code>：</p><pre><code class="lang-ts">import moment from &quot;moment&quot;;
import &quot;./style.css&quot;;

const app = document.getElementById(&quot;app&quot;);
if (app !== null) {
  app.innerText = moment().format();
  app.classList.add(&quot;bg-gray&quot;);
}</code></pre><h3>配置文件 tsconfig.json</h3><p>TypeScript 也有配置文件。在项目根目录下创建 <code>tsconfig.json</code> 即可。</p><p>具体规则可参考<a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">官方文档</a>。当我们配置好 React 后会再来修改 TypeScript 的规则配置。</p><h2>React.js</h2><p>使用 React 时我们会编写 <strong>JSX</strong>（或 TSX）语法的代码。JSX（或 TSX）全称 JavaScript（TypeScript）Extension，这是一种糅合了 HTML 和 JavaScript（TypeScript）语法的代码。当然，无论是浏览器还是 Node 都不支持这种代码，<strong>所以需要 Babel 为我们转译</strong>。其实，这样的代码中，类似 HTML 的那部分会被转译成 JavaScript 递归的函数调用的形式。</p><h3>集成到 Babel</h3><p>Babel 也提供了 React 的 preset（<a href="https://babeljs.io/docs/babel-preset-react">文档</a>），包含了对应插件。只要安装：</p><pre><code class="lang-bash">npm i @babel/preset-react --save-dev</code></pre><p>在 <code>webpack.config.js</code> 中设置匹配 .ts 或 .tsx 结尾的文件：</p><pre><code class="lang-js">// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      // ...
      {
        test: /\.tsx?$/,
        exclude: /node_modules/,
        use: {
          loader: &quot;babel-loader&quot;,
        },
      },
    ],
  },
};</code></pre><p>修改 Babel 配置文件 <code>babel.config.json</code>，添加 <strong>preset-react</strong>：</p><pre><code class="lang-json">// babel.config.json
{
  &quot;presets&quot;: [
    &quot;@babel/preset-env&quot;,
    &quot;@babel/preset-react&quot;,
    &quot;@babel/preset-typescript&quot;
  ]
}</code></pre><p>接下来，为了让 TypeScript 解释 TSX 语法，要在 <code>tsconfig.json</code> 中加入如下配置：</p><pre><code class="lang-json">// tsconfig.json
{
  &quot;compilerOptions&quot;: {
    &quot;strict&quot;: true,
    &quot;jsx&quot;: &quot;react&quot;,
    &quot;esModuleInterop&quot;: true,
    &quot;noEmit&quot;: true,
    &quot;allowImportingTsExtensions&quot;: true
  }
}</code></pre><p>这段配置文件中：</p><ul><li><strong>strict</strong> 设为 true 表示开启严格类型检查，包括不允许隐式 any 类型等等。</li><li><strong>jsx</strong> 设为 react，表示启用 JSX 支持。</li><li><strong>esModuleInterop</strong> 设为 true 允许用 import 语法直接导入 CommonJS 模块（否则，必须使用 require 的语法）。</li><li><strong>noEmit</strong> 表示不输出编译后的结果文件。由于在该配置中 TypeScript 是作为 Babel 的一个插件，转译后结果文件由 Babel 输出。</li><li><strong>allowImportingTsExtensions</strong> 表示允许导入 .tsx 类型的文件。</li></ul><p>以及，现在我们的脚本文件可以是 js、jsx、ts、tsx 格式了，要在 Tailwind 的配置文件中修改其检测的文件格式：</p><pre><code class="lang-js">// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [&quot;./src/**/*.{html,js,jsx,ts,tsx}&quot;],
  theme: {
    extend: {},
  },
  plugins: [],
};</code></pre><p>最后，别忘了安装 <strong>React 本体</strong>，以及其对应的类型定义：</p><pre><code class="lang-bash">npm i react react-dom --save
npm i @types/react @types/react-dom --save-dev</code></pre><h3>编写 React 组件</h3><p>现在，在 <code>src</code> 下创建 <code>App.tsx</code> 文件，我们可以在其中用 TSX 语法编写一个 React 组件了。</p><p>将之前写的显示时间的组件写进这里面：</p><pre><code class="lang-tsx">// App.tsx
import React from &quot;react&quot;;
import &quot;./style.css&quot;;
import moment from &quot;moment&quot;;

export default function App() {
  return (
    &lt;div className=&quot;App&quot;&gt;
      &lt;h1 className=&quot;text-4xl&quot;&gt;Hello, World!&lt;/h1&gt;
      &lt;p&gt;{moment().format()}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre><p>为了引用该组件，入口文件 <code>index.ts</code> 也需要用到 TSX 语法。因此，将其重命名为 <code>index.tsx</code>，修改为如下内容：</p><pre><code class="lang-tsx">// index.tsx
import React from &quot;react&quot;;
import { createRoot } from &quot;react-dom/client&quot;;

import App from &quot;./App.tsx&quot;;

const container = document.getElementById(&quot;app&quot;);
if (container !== null) {
  const root = createRoot(container);
  root.render(&lt;App /&gt;);
}</code></pre><p>同时，要在 webpack 配置中修改 entry：</p><pre><code class="lang-js">// webpack.config.js
module.exports = {
  // ...
  entry: &quot;./src/index.tsx&quot;,
  // ...
}</code></pre><p>现在，build 之后，打开生成的 HTML，可以看到我们用 React 写的组件了。</p><h2>ESLint</h2><p>ESLint 是一个代码检查工具。对于团队项目，统一代码风格十分重要，而 ESLint 可以方便地做到这一点：如果没有满足指定的代码风格，则显示警告或错误（如果在 IDE 中集成的话），或者拒绝提交或部署（如果在提交部署流程中集成的话）。</p><p>为了使流程更加清晰，我们还是选择<strong>将 ESLint 作为一个插件集成到 webpack</strong>。</p><h3>集成到 webpack</h3><p>安装 <strong>eslint-webpack-plugin</strong>（<a href="https://www.npmjs.com/package/eslint-webpack-plugin">相关文档</a>）：</p><pre><code class="lang-bash">npm i eslint-webpack-plugin --save-dev</code></pre><p>修改 webpack 的配置，添加该插件：</p><pre><code class="lang-js">// webpack.config.js
// ...
const ESLintPlugin = require('eslint-webpack-plugin');
module.exports = {
  // ...
  plugins: [
    // ...
    new ESLintPlugin({
      extensions: [&quot;js&quot;, &quot;jsx&quot;, &quot;ts&quot;, &quot;tsx&quot;],
    }),
  ],
  // ...
};</code></pre><p>配置文件中 <code>new ESLintPlugin({})</code> 可以传入一个 options 对象，用于指定 <strong>ESLint 插件选项</strong>（<a href="https://www.npmjs.com/package/eslint-webpack-plugin">文档</a>）。这里我们指定了要 lint 的文件拓展名。</p><h3>配置文件 .eslintrc.js</h3><p>可以使用 <code>@eslint/config</code> 创建配置文件（<a href="https://eslint.org/docs/latest/use/getting-started">文档</a>），这是一个友好的交互式命令：</p><pre><code class="lang-bash">npm init @eslint/config</code></pre><p>在其中可以选择「项目使用了 React.js、TypeScript」，该命令会自动为我们安装配置对应的 ESLint 插件。</p><p>运行完成后，除了安装了一堆插件，项目根目录会产生配置文件 <code>.eslintrc.js</code>（或者其他文件格式，取决于你的选择）。</p><pre><code class="lang-js">// .eslintrc.js
module.exports = {
  env: {
    browser: true,
    es2021: true,
  },
  extends: [&quot;standard-with-typescript&quot;, &quot;plugin:react/recommended&quot;],
  overrides: [
    {
      env: {
        node: true,
      },
      files: [&quot;.eslintrc.{js,cjs}&quot;],
      parserOptions: {
        sourceType: &quot;script&quot;,
      },
    },
  ],
  parserOptions: {
    ecmaVersion: &quot;latest&quot;,
    sourceType: &quot;module&quot;,
  },
  plugins: [&quot;react&quot;],
};</code></pre><p>现在，再次 build，ESLint 会按照我们设定的规则进行代码检查。</p><p>可以在配置文件中添加一些自己习惯的规则，比如使用双引号、行末加分号。并且，需要设置对于 <code>*.config.js</code> 这类配置文件的特殊检测规则。我的 <code>.eslintrc.js</code> 文件设置如下：</p><pre><code class="lang-js">// .eslintrc.js
module.exports = {
  env: {
    browser: true,
    es2021: true
  },
  extends: [&quot;standard-with-typescript&quot;, &quot;plugin:react/recommended&quot;],
  overrides: [
    {
      env: {
        node: true
      },
      files: [&quot;.eslintrc.js&quot;, &quot;*.config.js&quot;],
      parserOptions: {
        sourceType: &quot;script&quot;
      },
      extends: [&quot;plugin:@typescript-eslint/disable-type-checked&quot;],
      rules: {
        &quot;@typescript-eslint/no-var-requires&quot;: &quot;off&quot;
      }
    }
  ],
  parserOptions: {
    ecmaVersion: &quot;latest&quot;,
    sourceType: &quot;module&quot;
  },
  rules: {
    &quot;@typescript-eslint/semi&quot;: [&quot;error&quot;, &quot;always&quot;],
    &quot;@typescript-eslint/quotes&quot;: [&quot;error&quot;, &quot;double&quot;]
  },
  plugins: [&quot;react&quot;]
};</code></pre><p>⚠️ <strong>一个坑点：</strong>使用 TypeScript 时，由于使用 typescript-eslint 的解析器而非默认解析器（<a href="https://github.com/mightyiam/eslint-config-standard-with-typescript">文档</a>），添加规则要写 <code>@typescript-eslint/quotes</code> 而非 <code>quotes</code>，否则不会生效。例如：</p><pre><code class="lang-js">// eslintrc.js
module.exports = {
  // ...
  rules: {
    &quot;@typescript-eslint/quotes&quot;: [&quot;error&quot;, &quot;double&quot;],
    &quot;@typescript-eslint/semi&quot;: [&quot;error&quot;, &quot;always&quot;],
  },
  // ...
};</code></pre><p>💡 或许你同时在 IDE 中使用 <strong>Prettier</strong> 一类的<strong>代码格式化工具</strong>。其文档中 <a href="https://prettier.io/docs/en/comparison">Prettier vs. Linters</a> 介绍了这两种工具的区别；<a href="https://prettier.io/docs/en/integrating-with-linters.html">Integrating with Linters</a> 介绍了其与 linter 的集成指南。简而言之，在 ESLint 配置中应用 <a href="https://github.com/prettier/eslint-config-prettier">eslint-config-prettier</a> 规则集即可自动关闭所有与 Prettier 冲突的规则。不过我更推荐的是在 IDE 中安装 ESLint 插件，对于 js 类文件直接使用 ESLint 作为代码格式化工具，这样能够确保遵循 eslintrc 中的规则。</p><p>（ESLint 这部分配置起来还是挺麻烦的，尤其要集成到 VSCode，同时兼容 TypeScript，并考虑到其和 Prettier 的冲突。改天配置好了一个比较 fancy 的方案再单独写一篇）</p><h2>Recap：站在巨人的肩膀上</h2><p>至此，一套比较完整的<strong>前端项目 starter</strong> 终于配置完毕了。完整的项目可以在<a href="https://github.com/Skywt2003/starter.git">这个仓库</a>查看。</p><p>回顾一下，我们首先使用了 <strong>webpack</strong> 作为打包工具；其 <strong>PostCSS</strong> 插件能够对 CSS 进行处理；<strong>Tailwind</strong> 则可以作为 PostCSS 插件集成。我们使用 <strong>Babel</strong> 这个 transpiler 处理各种脚本文件，其中 <strong>env</strong> preset 将 ECMAScript 较先进的特性转译为旧特性的实现，确保兼容性；<strong>TypeScript</strong> 和 <strong>React JSX</strong> 两个 preset 则分别将它们各自的语法转译成 JavaScript。最后，我们使用 <strong>ESLint</strong> 作为代码质量检查工具，并配置其针对 TypeScript 和 JSX 的规则。</p><p>使用的工具链关系示意图如下：</p><p><img src="https://blog.skywt.cn/usr/uploads/2024/03/543791890.png" alt="配置完毕后的工具链示意图" title="配置完毕后的工具链示意图"></p><p>相比从前，各种工具让开发的过程变得越来越优雅和美妙。然而每个工具背后，都有无数前人的辛勤付出，没有他们的这些努力，我们无法得到这样现代化的前端开发体验。</p><p>现代前端开发，就是<strong>站在巨人的肩膀上</strong>。</p><h3>一点思考 🤔</h3><p>最后，还有一个我的疑问：<strong>相比其他领域，为什么 Web 前端开发的工具链会呈现如此复杂的形态呢？</strong>我体验过 iOS 开发，也了解过基于 Qt 等框架的客户端开发，我个人的感觉是没有一个领域的客户端开发像 Web 前端这样有如此庞大复杂的工具链：某个工具可以配置插件，插件又有插件，插件的插件又有插件……那么归根结底，Web 前端工具链这种复杂的形式，是历史发展的必然，是某种设计缺陷的后果，还是某种设计思想的体现？🤔</p><p>欢迎分享你的思考。</p><h2>值得一读</h2><blockquote><p>Web development used to be a great entry point for people new to programming precisely because it was so easy to get up and running; nowadays it can be quite daunting, especially because the various tools tend to change rapidly.</p><p>—— Modern JavaScript Explained For Dinosaurs</p></blockquote><p><strong>值得一读的相关文章；</strong></p><ul><li><a href="https://peterxjang.com/blog/modern-javascript-explained-for-dinosaurs.html">Modern JavaScript Explained For Dinosaurs</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Introducing_complete_toolchain">介绍完整的工具链 - 学习 Web 开发 | MDN</a></li><li><a href="https://pomb.us/build-your-own-react/">Build your own React</a></li></ul> </article> <hr class="my-8" data-astro-cid-4sn4zg3r> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();;(()=>{var b=Object.defineProperty;var f=(c,o,i)=>o in c?b(c,o,{enumerable:!0,configurable:!0,writable:!0,value:i}):c[o]=i;var l=(c,o,i)=>(f(c,typeof o!="symbol"?o+"":o,i),i);var p;{let c={0:t=>m(t),1:t=>i(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(i(t)),5:t=>new Set(i(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},o=t=>{let[e,r]=t;return e in c?c[e](r):void 0},i=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([e,r])=>[e,o(r)]));customElements.get("astro-island")||customElements.define("astro-island",(p=class extends HTMLElement{constructor(){super(...arguments);l(this,"Component");l(this,"hydrator");l(this,"hydrate",async()=>{var d;if(!this.hydrator||!this.isConnected)return;let e=(d=this.parentElement)==null?void 0:d.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let r=this.querySelectorAll("astro-slot"),a={},h=this.querySelectorAll("template[data-astro-template]");for(let n of h){let s=n.closest(this.tagName);s!=null&&s.isSameNode(this)&&(a[n.getAttribute("data-astro-template")||"default"]=n.innerHTML,n.remove())}for(let n of r){let s=n.closest(this.tagName);s!=null&&s.isSameNode(this)&&(a[n.getAttribute("name")||"default"]=n.innerHTML)}let u;try{u=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(n){let s=this.getAttribute("component-url")||"<unknown>",y=this.getAttribute("component-export");throw y&&(s+=` (export ${y})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),n),n}await this.hydrator(this)(this.Component,u,a,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});l(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),r.disconnect(),this.childrenConnectedCallback()},r=new MutationObserver(()=>{var a;((a=this.lastChild)==null?void 0:a.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});r.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}start(){let e=JSON.parse(this.getAttribute("opts")),r=this.getAttribute("client");if(Astro[r]===void 0){window.addEventListener(`astro:${r}`,()=>this.start(),{once:!0});return}Astro[r](async()=>{let a=this.getAttribute("renderer-url"),[h,{default:u}]=await Promise.all([import(this.getAttribute("component-url")),a?import(a):()=>()=>{}]),d=this.getAttribute("component-export")||"default";if(!d.includes("."))this.Component=h[d];else{this.Component=h;for(let n of d.split("."))this.Component=this.Component[n]}return this.hydrator=u,this.hydrate},e,this)}attributeChangedCallback(){this.hydrate()}},l(p,"observedAttributes",["props"]),p))}})();</script><astro-island uid="tMp5M" component-url="/_astro/Comments.nA8khF3T.js" component-export="default" renderer-url="/_astro/client.d8bzWiGl.js" props="{&quot;slug&quot;:[0,&quot;configure-a-modern-frontend-toolchain-from-scratch&quot;],&quot;permalink&quot;:[0,&quot;https://blog.skywt.cn/posts/configure-a-modern-frontend-toolchain-from-scratch&quot;],&quot;data-astro-cid-4sn4zg3r&quot;:[0,true]}" ssr="" client="load" opts="{&quot;name&quot;:&quot;Comments&quot;,&quot;value&quot;:true}" await-children=""><h2><i class="ri-discuss-line"></i> 暂无评论</h2><hr class="my-8"/><h2><i class="ri-discuss-line"></i> 发表评论</h2><p class="primary-color card my-4 p-2">🚧 新博客系统的评论功能仍在开发中，敬请期待。可以前往<a href="https://blog.skywt.cn/posts/configure-a-modern-frontend-toolchain-from-scratch" class="link underline">原博客的这篇文章</a>底部评论区发表评论。</p><!--astro:end--></astro-island> </section> </main>  <footer class="mt-16 py-8 bg-gray-100 dark:bg-neutral-900"> <div class="wide-container secondary-color text-sm"> <div class="flex justify-between flex-wrap"> <div class="m-2"> <a href="/" class="link">SkyWT</a> <span>
/
<a href="/blog" class="link"> 博客</a> </span><span>
/
从零开始，配置一套现代前端工具链 </span> </div> <div class="m-2"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> 
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv>  博客 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv>  实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/friends" data-astro-cid-tfcnbjmv>  友人 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv>  关于 </a> </li> </ul>  </div> </div> <hr class="my-4"> <div class="flex justify-between flex-wrap"> <p class="m-2">
&#169; 2017-2024 <a href="/" class="link">SkyWT</a>
|
<a href="/sitemap.xml" class="link">站点地图</a>
|
<a href="/friends" class="link">友情链接</a>
|
<a href="https://foreverblog.cn/go.html" class="link">虫洞</a> <!-- |
        <a href="https://github.com/Skywt2003/Daydreamer" class="link"
          >Daydreamer</a
        > --> </p> <div class="m-2"> <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" class="inline-block mx-1" data-astro-cid-h3ykra2n> <img class="icon" src="/cc/cc.svg" data-astro-cid-h3ykra2n> <img class="icon" src="/cc/by.svg" data-astro-cid-h3ykra2n> <img class="icon" src="/cc/nc.svg" data-astro-cid-h3ykra2n>   </a>  <a href="https://notbyai.fyi" target="_blank" class="inline-block mx-1" data-astro-cid-hwbnc4sm> <img src="/not-by-ai-light.svg" alt="Not By AI Badge" class="badge inline-block dark:hidden" data-astro-cid-hwbnc4sm> <img src="/not-by-ai-dark.svg" alt="Not By AI Badge" class="badge hidden dark:inline-block" data-astro-cid-hwbnc4sm> </a>  <a href="https://www.foreverblog.cn/" target="_blank" class="inline-block mx-1"> <img src="https://img.foreverblog.cn/logo_en_default.png" alt="Forever Blog Badage" class="inline-block h-4 grayscale"> </a> </div> </div> <div class="flex justify-between flex-wrap"> <p class="m-2"> <a href="https://beian.miit.gov.cn/" target="_blank" class="link">
浙 ICP 备 2021019606 号 - 1</a>
|
<a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33080202000472" target="_blank" class="link before:content-[url('/mps.png')] before:align-middle">
浙公网安备 33080202000472 号</a> </p> <p class="m-2"> <!-- <span class="align-middle">由</span>
        <a
          href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"
          class="inline-block align-middle"
        >
          <img src="/upyun.png" class="h-6" />
        </a>
        <span class="align-middle">提供 CDN 加速、云存储服务</span> --> </p> </div> </div> </footer> </body></html> 